<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: main.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: main.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * @module main
 * Application entry point.
 * Initializes components, manages state, and wires event flow.
 */

import './style.css';

import { initFileUpload, showFileInfo, resetFileUpload } from './components/FileUpload.js';
import { initFindReplace, showFindReplaceSection, hideFindReplaceSection, getOptions, setButtonStates } from './components/FindReplace.js';
import { initReplacementList, getPairs, resetReplacementList } from './components/ReplacementList.js';
import { renderTextPreview, renderHtmlPreview, renderEmptyState } from './components/Preview.js';
import { updateMatchCount, hideMatchInfo } from './components/MatchInfo.js';
import { initThemeToggle } from './components/ThemeToggle.js';
import { getFileExtension } from './utils/fileHelpers.js';
import { downloadFile } from './utils/download.js';
import { loadDocx, getDocumentXml, extractTextFromXml, replaceInDocx, generateHtmlPreview, exportDocx } from './core/docxProcessor.js';
import { loadTxt, exportTxt } from './core/txtProcessor.js';
import { replaceAll } from './core/replacer.js';

// ── App State ──────────────────────────────────────────────────
const state = {
    /** @type {File|null} */
    currentFile: null,
    /** @type {'docx'|'txt'|null} */
    fileType: null,
    /** @type {string} - Original text content (for .txt) */
    originalText: '',
    /** @type {string} - Current working text (for .txt) */
    currentText: '',
    /** @type {Object|null} - Original ZIP (for .docx) */
    originalZip: null,
    /** @type {Object|null} - Current working ZIP (for .docx) */
    currentZip: null,
    /** @type {string} - HTML preview (for .docx) */
    previewHtml: '',
    /** @type {string|null} - Previous state for undo */
    undoText: null,
    /** @type {Object|null} - Previous ZIP for undo */
    undoZip: null,
    /** @type {boolean} - Whether a replacement has been applied */
    hasReplaced: false,
};

// ── Initialize ─────────────────────────────────────────────────
document.addEventListener('DOMContentLoaded', () => {
    initThemeToggle();

    initFileUpload({
        onFileSelected: handleFileSelected,
        onError: showToast,
    });

    initFindReplace({
        onReplaceAll: handleReplaceAll,
        onUndo: handleUndo,
        onDownload: handleDownload,
        onOptionsChange: handleInputChange,
    });

    initReplacementList({
        onInputChange: handleInputChange,
    });

    document.getElementById('file-remove').addEventListener('click', handleFileRemove);
});

// ── File Handling ──────────────────────────────────────────────

/**
 * Processes a newly selected file.
 *
 * @param {File} file - The uploaded file.
 */
async function handleFileSelected(file) {
    try {
        state.currentFile = file;
        const ext = getFileExtension(file);
        state.fileType = ext === '.docx' ? 'docx' : 'txt';

        showFileInfo(file.name);
        showFindReplaceSection();

        if (state.fileType === 'txt') {
            await loadTextFile(file);
        } else {
            await loadDocxFile(file);
        }

        resetUndoState();
        handleInputChange();
        showToast('File loaded successfully!', 'success');
    } catch (error) {
        console.error('Error loading file:', error);
        showToast('Failed to load file. Please try again.', 'error');
    }
}

/**
 * Loads and previews a .txt file.
 *
 * @param {File} file - The .txt file.
 */
async function loadTextFile(file) {
    state.originalText = await loadTxt(file);
    state.currentText = state.originalText;
}

/**
 * Loads and previews a .docx file.
 *
 * @param {File} file - The .docx file.
 */
async function loadDocxFile(file) {
    state.originalZip = await loadDocx(file);
    // Clone the zip for working copy
    const arrayBuffer = await file.arrayBuffer();
    state.currentZip = await loadDocx(file);
    state.previewHtml = await generateHtmlPreview(arrayBuffer);

    // Also extract text for matching purposes
    const xml = await getDocumentXml(state.originalZip);
    state.originalText = extractTextFromXml(xml);
    state.currentText = state.originalText;
}

/**
 * Removes the current file and resets everything.
 */
function handleFileRemove() {
    state.currentFile = null;
    state.fileType = null;
    state.originalText = '';
    state.currentText = '';
    state.originalZip = null;
    state.currentZip = null;
    state.previewHtml = '';

    resetUndoState();
    resetFileUpload();
    hideFindReplaceSection();
    renderEmptyState();
    hideMatchInfo();
    resetReplacementList(handleInputChange);
    setButtonStates({ canReplace: false, canUndo: false, canDownload: false });
}

// ── Preview &amp; Matching ─────────────────────────────────────────

/**
 * Called whenever find/replace inputs or options change.
 * Updates the preview with highlighted matches.
 */
function handleInputChange() {
    if (!state.currentFile) {
        return;
    }

    const pairs = getPairs();
    const options = getOptions();
    const hasPatterns = pairs.length > 0;

    // Use the first pair's pattern for live preview highlighting
    const firstPattern = hasPatterns ? pairs[0].find : '';

    let matchCount = 0;

    if (state.fileType === 'txt') {
        matchCount = renderTextPreview(state.currentText, firstPattern, options);
    } else {
        matchCount = renderHtmlPreview(state.previewHtml, firstPattern, options);
    }

    updateMatchCount(matchCount);
    setButtonStates({
        canReplace: hasPatterns &amp;&amp; matchCount > 0,
        canUndo: state.hasReplaced,
        canDownload: state.hasReplaced,
    });
}

// ── Replace All ────────────────────────────────────────────────

/**
 * Applies all replacement pairs to the document.
 */
async function handleReplaceAll() {
    try {
        const pairs = getPairs();
        const options = getOptions();

        if (pairs.length === 0) {
            return;
        }

        // Save undo state
        state.undoText = state.currentText;
        state.undoZip = state.currentZip;

        if (state.fileType === 'txt') {
            await applyTextReplacements(pairs, options);
        } else {
            await applyDocxReplacements(pairs, options);
        }

        state.hasReplaced = true;
        handleInputChange();

        const totalPairs = pairs.length;
        showToast(`Replaced ${totalPairs} pattern${totalPairs > 1 ? 's' : ''} successfully!`, 'success');
    } catch (error) {
        console.error('Error during replacement:', error);
        showToast('Replacement failed. Please try again.', 'error');
    }
}

/**
 * Applies replacements to a .txt document.
 *
 * @param {Array&lt;{ find: string, replace: string }>} pairs - Replacement pairs.
 * @param {object} options - Replace options.
 */
async function applyTextReplacements(pairs, options) {
    let text = state.currentText;

    for (const pair of pairs) {
        text = replaceAll(text, pair.find, pair.replace, options);
    }

    state.currentText = text;
}

/**
 * Applies replacements to a .docx document.
 *
 * @param {Array&lt;{ find: string, replace: string }>} pairs - Replacement pairs.
 * @param {object} options - Replace options.
 */
async function applyDocxReplacements(pairs, options) {
    // Reload the current zip from the file to get a fresh copy
    let zip = state.currentZip;

    for (const pair of pairs) {
        zip = await replaceInDocx(zip, pair.find, pair.replace, options);
    }

    state.currentZip = zip;

    // Regenerate preview from modified zip
    const blob = await exportDocx(zip);
    const arrayBuffer = await blob.arrayBuffer();
    state.previewHtml = await generateHtmlPreview(arrayBuffer);

    // Update text for matching
    const xml = await getDocumentXml(zip);
    state.currentText = extractTextFromXml(xml);
}

// ── Undo ───────────────────────────────────────────────────────

/**
 * Reverts the last replacement operation.
 */
async function handleUndo() {
    if (!state.hasReplaced) {
        return;
    }

    state.currentText = state.undoText || state.originalText;
    state.currentZip = state.undoZip || state.originalZip;

    if (state.fileType === 'docx' &amp;&amp; state.currentZip) {
        const blob = await exportDocx(state.currentZip);
        const arrayBuffer = await blob.arrayBuffer();
        state.previewHtml = await generateHtmlPreview(arrayBuffer);
    }

    resetUndoState();
    handleInputChange();
    showToast('Undo successful!', 'success');
}

/**
 * Resets the undo state.
 */
function resetUndoState() {
    state.undoText = null;
    state.undoZip = null;
    state.hasReplaced = false;
}

// ── Download ───────────────────────────────────────────────────

/**
 * Downloads the modified document.
 */
async function handleDownload() {
    try {
        const originalName = state.currentFile.name;
        const dotIndex = originalName.lastIndexOf('.');
        const baseName = dotIndex > 0 ? originalName.slice(0, dotIndex) : originalName;
        const extension = dotIndex > 0 ? originalName.slice(dotIndex) : '';
        const downloadName = `${baseName}_replaced${extension}`;

        let blob;

        if (state.fileType === 'txt') {
            blob = exportTxt(state.currentText);
        } else {
            blob = await exportDocx(state.currentZip);
        }

        downloadFile(blob, downloadName);
        showToast('Download started!', 'success');
    } catch (error) {
        console.error('Download error:', error);
        showToast('Download failed. Please try again.', 'error');
    }
}

// ── Toast ──────────────────────────────────────────────────────

/** @type {number|null} - Active toast timeout */
let toastTimeout = null;

/**
 * Shows a toast notification.
 *
 * @param {string} message - Message text.
 * @param {'success'|'error'|'warning'} [type='success'] - Toast type.
 */
function showToast(message, type = 'success') {
    const toast = document.getElementById('status-toast');
    toast.textContent = message;
    toast.className = `toast toast-${type} show`;
    toast.hidden = false;

    if (toastTimeout) {
        clearTimeout(toastTimeout);
    }

    toastTimeout = setTimeout(() => {
        toast.classList.remove('show');
        setTimeout(() => {
            toast.hidden = true;
        }, 300);
    }, 3000);
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="FileUpload%250AManages%2520the%2520drag-and-drop%2520upload%2520zone%2520and%2520file%2520input.module_.html">FileUpload
Manages the drag-and-drop upload zone and file input.</a></li><li><a href="FindReplace%250AManages%2520the%2520find_replace%2520section%2520visibility%2520and%2520action%2520buttons.module_.html">FindReplace
Manages the find/replace section visibility and action buttons.</a></li><li><a href="MatchInfo%250ADisplays%2520the%2520match%2520count%2520badge%2520in%2520the%2520preview%2520header.module_.html">MatchInfo
Displays the match count badge in the preview header.</a></li><li><a href="Preview%250ARenders%2520document%2520content%2520in%2520the%2520preview%2520panel%2520with%2520match%2520highlights.module_.html">Preview
Renders document content in the preview panel with match highlights.</a></li><li><a href="ReplacementList%250AManages%2520multiple%2520find_replace%2520input%2520pairs.module_.html">ReplacementList
Manages multiple find/replace input pairs.</a></li><li><a href="ThemeToggle%250ADark_light%2520mode%2520toggle%2520with%2520localStorage%2520persistence%2520and%2520system%2520preference%2520detection.module_.html">ThemeToggle
Dark/light mode toggle with localStorage persistence and system preference detection.</a></li><li><a href="docxProcessor%250AHandles%2520.docx%2520file%2520loading,%2520XML-level%2520text%2520replacement,%2520preview%2520generation,%2520and%2520export.%250AUses%2520JSZip%2520for%2520ZIP%2520manipulation%2520and%2520Mammoth%2520for%2520HTML%2520preview%2520rendering.module_.html">docxProcessor
Handles .docx file loading, XML-level text replacement, preview generation, and export.
Uses JSZip for ZIP manipulation and Mammoth for HTML preview rendering.</a></li><li><a href="download%250AWrapper%2520around%2520FileSaver.js%2520for%2520downloading%2520files.module_.html">download
Wrapper around FileSaver.js for downloading files.</a></li><li><a href="fileHelpers%250AUtility%2520functions%2520for%2520file%2520type%2520detection%2520and%2520validation.module_.html">fileHelpers
Utility functions for file type detection and validation.</a></li><li><a href="main%250AApplication%2520entry%2520point.%250AInitializes%2520components,%2520manages%2520state,%2520and%2520wires%2520event%2520flow.module_.html">main
Application entry point.
Initializes components, manages state, and wires event flow.</a></li><li><a href="replacer%250ACore%2520find-and-replace%2520engine.%250APure%2520functions%2520%25E2%2580%2594%2520no%2520DOM,%2520no%2520side%2520effects.module_.html">replacer
Core find-and-replace engine.
Pure functions — no DOM, no side effects.</a></li><li><a href="txtProcessor%250APlain%2520text%2520file%2520reading,%2520replacing,%2520and%2520exporting.module_.html">txtProcessor
Plain text file reading, replacing, and exporting.</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.5</a> on Thu Feb 19 2026 15:11:14 GMT+0700 (Western Indonesia Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
